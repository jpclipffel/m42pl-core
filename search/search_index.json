{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"M42PL - A Data Manipulation Language M42PL is a Data Manipulation Language , inspired by Unix shells and Splunk . The language is extremely simple to learn and to use. It is designed to make data manipulation trivial, even for non-technical users. Examples Query an URL | url 'https://api.ipify.org' | fields response.content, response.status | eval message = 'Your external IP is ' + response.content Run a HTTP server | http_server with '*' on '/foo' = [ | echo | eval path='foo', mode='infinite+iterator' | fields path, mode ], '*' on '/bar' = [ | eval path='bar', mode='infinite+stream' | fields path, mode ], '*' on '/{path}' = [] Capture and stream a video This requires the installation of m42pl-vision | cv2_read | cv2_resize ratio=0.5 | zmq_pub topic='webcam' Display a video stream This requires the installation of m42pl-vision | zmq_sub topic='webcam' | decode {zmq.frames[0]} with 'msgpack' | cv2_show cv2.frame","title":"Home"},{"location":"#m42pl-a-data-manipulation-language","text":"M42PL is a Data Manipulation Language , inspired by Unix shells and Splunk . The language is extremely simple to learn and to use. It is designed to make data manipulation trivial, even for non-technical users.","title":"M42PL - A Data Manipulation Language"},{"location":"#examples","text":"Query an URL | url 'https://api.ipify.org' | fields response.content, response.status | eval message = 'Your external IP is ' + response.content Run a HTTP server | http_server with '*' on '/foo' = [ | echo | eval path='foo', mode='infinite+iterator' | fields path, mode ], '*' on '/bar' = [ | eval path='bar', mode='infinite+stream' | fields path, mode ], '*' on '/{path}' = [] Capture and stream a video This requires the installation of m42pl-vision | cv2_read | cv2_resize ratio=0.5 | zmq_pub topic='webcam' Display a video stream This requires the installation of m42pl-vision | zmq_sub topic='webcam' | decode {zmq.frames[0]} with 'msgpack' | cv2_show cv2.frame","title":"Examples"},{"location":"components/","text":"Components M42PL is built on 5 kind of components, each of them providing a set of core functionnalities and each of them being extendable and replacable. Core : The core project Commands : The language commands and constructs KVStores : The key-value interfaces Encoders : The data encoding/decoding codecs Dispatchers : The pipelines runners/executors/schedulers/...","title":"Overview"},{"location":"components/#components","text":"M42PL is built on 5 kind of components, each of them providing a set of core functionnalities and each of them being extendable and replacable. Core : The core project Commands : The language commands and constructs KVStores : The key-value interfaces Encoders : The data encoding/decoding codecs Dispatchers : The pipelines runners/executors/schedulers/...","title":"Components"},{"location":"components/commands/","text":"Commands To do.","title":"Commands"},{"location":"components/commands/#commands","text":"To do.","title":"Commands"},{"location":"components/core/","text":"Core To do.","title":"Core"},{"location":"components/core/#core","text":"To do.","title":"Core"},{"location":"components/dispatchers/","text":"Dispatchers To do.","title":"Dispatchers"},{"location":"components/dispatchers/#dispatchers","text":"To do.","title":"Dispatchers"},{"location":"components/encoders/","text":"Dispatchers To do.","title":"Encoders"},{"location":"components/encoders/#dispatchers","text":"To do.","title":"Dispatchers"},{"location":"components/kvstores/","text":"KVStores To do.","title":"KVStores"},{"location":"components/kvstores/#kvstores","text":"To do.","title":"KVStores"},{"location":"fields/","text":"Fields Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield Eval : An evaulation expression, e.g. at(list, 0) JsonPath : A JsonPath expression, e.g. {list[0].name} Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ] Fields interpretation It is important to note that fields values are dynamic while fields types are static . M42PL decides which field functor has to be instanciated using the field syntax. For example, the field {user.emails[0]} is matched as a JsonPath field. Each time an event is processed, the same JsonPath instance will be called with the event as first parameter to extrat the first item ( [0] ) in the list emails in the root field user . Literal fields Although literal fields always return the same value, they are also implemented as functors in M42PL.","title":"Overview"},{"location":"fields/#fields","text":"Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield Eval : An evaulation expression, e.g. at(list, 0) JsonPath : A JsonPath expression, e.g. {list[0].name} Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ]","title":"Fields"},{"location":"fields/#fields-interpretation","text":"It is important to note that fields values are dynamic while fields types are static . M42PL decides which field functor has to be instanciated using the field syntax. For example, the field {user.emails[0]} is matched as a JsonPath field. Each time an event is processed, the same JsonPath instance will be called with the event as first parameter to extrat the first item ( [0] ) in the list emails in the root field user . Literal fields Although literal fields always return the same value, they are also implemented as functors in M42PL.","title":"Fields interpretation"},{"location":"fields/eval/","text":"Evaluated fields Evaluated fields returns the result of an evaluation expression . They are similar to some programming languages lambdas . Syntax Evaluated fields are enclosed in back-quotes: current_year=`strftime(now(), '%Y')` Example Write the output of the command ps aux in files, with on file per user name. Script: | process 'ps' 'aux' | regex line with '(?P<user>[^\\s]+).*' | writefile `line + '\\n'` to `'/tmp/processes-' + user + '.log'` Generated files (truncated output): ls -l /tmp/processes-* -rw-rw-r-- 1 ... /tmp/processes-avahi.log -rw-rw-r-- 1 ... /tmp/processes-colord.log -rw-rw-r-- 1 ... /tmp/processes-message+.log -rw-rw-r-- 1 ... /tmp/processes-root.log -rw-rw-r-- 1 ... /tmp/processes-syslog.log -rw-rw-r-- 1 ... /tmp/processes-systemd+.log -rw-rw-r-- 1 ... /tmp/processes-USER.log -rw-rw-r-- 1 ... /tmp/processes-uuidd.log","title":"Evaluated"},{"location":"fields/eval/#evaluated-fields","text":"Evaluated fields returns the result of an evaluation expression . They are similar to some programming languages lambdas .","title":"Evaluated fields"},{"location":"fields/eval/#syntax","text":"Evaluated fields are enclosed in back-quotes: current_year=`strftime(now(), '%Y')`","title":"Syntax"},{"location":"fields/eval/#example","text":"Write the output of the command ps aux in files, with on file per user name. Script: | process 'ps' 'aux' | regex line with '(?P<user>[^\\s]+).*' | writefile `line + '\\n'` to `'/tmp/processes-' + user + '.log'` Generated files (truncated output): ls -l /tmp/processes-* -rw-rw-r-- 1 ... /tmp/processes-avahi.log -rw-rw-r-- 1 ... /tmp/processes-colord.log -rw-rw-r-- 1 ... /tmp/processes-message+.log -rw-rw-r-- 1 ... /tmp/processes-root.log -rw-rw-r-- 1 ... /tmp/processes-syslog.log -rw-rw-r-- 1 ... /tmp/processes-systemd+.log -rw-rw-r-- 1 ... /tmp/processes-USER.log -rw-rw-r-- 1 ... /tmp/processes-uuidd.log","title":"Example"},{"location":"fields/jsonpath/","text":"JsonPath fields JsonPath fields extract a field's value from an event using a JsonPath expression. JsonPath syntax reference: https://pypi.org/project/jsonpath-ng/ https://goessner.net/articles/JsonPath/ Syntax JsonPath fields are enclosed in brackets: field={a.b.c[0]} Example | make | eval mpl.encoders = list('raw', 'json') | rename {mpl.encoders[0]} as encoders {mpl.encoders[0]} is a JsonPath expression which selects the first item ( [0] ) of the nested field encoders in the root field mpl . { \"mpl\": { \"encoders\": [ \"json\" ] }, \"encoders\": \"raw\" }","title":"JsonPath"},{"location":"fields/jsonpath/#jsonpath-fields","text":"JsonPath fields extract a field's value from an event using a JsonPath expression. JsonPath syntax reference: https://pypi.org/project/jsonpath-ng/ https://goessner.net/articles/JsonPath/","title":"JsonPath fields"},{"location":"fields/jsonpath/#syntax","text":"JsonPath fields are enclosed in brackets: field={a.b.c[0]}","title":"Syntax"},{"location":"fields/jsonpath/#example","text":"| make | eval mpl.encoders = list('raw', 'json') | rename {mpl.encoders[0]} as encoders {mpl.encoders[0]} is a JsonPath expression which selects the first item ( [0] ) of the nested field encoders in the root field mpl . { \"mpl\": { \"encoders\": [ \"json\" ] }, \"encoders\": \"raw\" }","title":"Example"},{"location":"fields/literal/","text":"Literal fields Literal fields are literal values, which are not read from the events. You can use literal fields to configure static commands values. Syntax Strings are enclosed in simple quotes , e.g. 'a string' Numbers (integer or floats) are written as-is, e.g. 42 , 21.42 Quotes matters Enclosing a string into double-quotes as \"some string\" as a different meaning: see path fields Examples Generate 2 events | make count=2 2 is a literal value, interpreted as in integer {} {} Query an URL | url 'https://api.ipify.org' 'https://api.ipify.org' is a literal value, interpreted as a string { \"time\": 1234, \"request\": { \"method\": \"GET\", \"url\": \"https://api.ipify.org\", \"headers\": {}, \"data\": {} }, \"response\": { \"status\": 200, \"reason\": \"OK\", \"mime\": { \"type\": \"text/plain\" }, \"headers\": { \"Server\": \"Cowboy\", \"Connection\": \"keep-alive\", \"Content-Type\": \"text/plain\", \"Vary\": \"Origin\", \"Date\": \"....\", \"Content-Length\": \"13\", \"Via\": \"1.1 vegur\" }, \"content\": \"...\" } }","title":"Literal"},{"location":"fields/literal/#literal-fields","text":"Literal fields are literal values, which are not read from the events. You can use literal fields to configure static commands values.","title":"Literal fields"},{"location":"fields/literal/#syntax","text":"Strings are enclosed in simple quotes , e.g. 'a string' Numbers (integer or floats) are written as-is, e.g. 42 , 21.42 Quotes matters Enclosing a string into double-quotes as \"some string\" as a different meaning: see path fields","title":"Syntax"},{"location":"fields/literal/#examples","text":"","title":"Examples"},{"location":"fields/literal/#generate-2-events","text":"| make count=2 2 is a literal value, interpreted as in integer {} {}","title":"Generate 2 events"},{"location":"fields/literal/#query-an-url","text":"| url 'https://api.ipify.org' 'https://api.ipify.org' is a literal value, interpreted as a string { \"time\": 1234, \"request\": { \"method\": \"GET\", \"url\": \"https://api.ipify.org\", \"headers\": {}, \"data\": {} }, \"response\": { \"status\": 200, \"reason\": \"OK\", \"mime\": { \"type\": \"text/plain\" }, \"headers\": { \"Server\": \"Cowboy\", \"Connection\": \"keep-alive\", \"Content-Type\": \"text/plain\", \"Vary\": \"Origin\", \"Date\": \"....\", \"Content-Length\": \"13\", \"Via\": \"1.1 vegur\" }, \"content\": \"...\" } }","title":"Query an URL"},{"location":"fields/path/","text":"Path fields Path fields are event's attributes names, which may use a dotted notattion (e.g. some.field.name ) to represent nested events fields. Syntax Root fields are written as-in, e.g. fieldName Nested fields are sperated by a dot, e.g. user.name , user.identity.name Fields with spaces in their name can may be encosed in double-quotes, e.g. \"user name\" , \"user.last name\" Quotes matters Enclosing a fields into single-quotes as 'some string' as a different meaning: see literal fields Examples Generate fields | make | eval userid = 'jdoe', user.name = 'John', user.lastname = 'Doe', \"user.twitter account\" = \"@JDoe\", user.loc = list(1, 2, 3) { \"userid\": \"jdoe\", \"user\": { \"name\": \"John\", \"lastname\": \"Doe\", \"twitter account\": \"@JDoe\" } }","title":"Path"},{"location":"fields/path/#path-fields","text":"Path fields are event's attributes names, which may use a dotted notattion (e.g. some.field.name ) to represent nested events fields.","title":"Path fields"},{"location":"fields/path/#syntax","text":"Root fields are written as-in, e.g. fieldName Nested fields are sperated by a dot, e.g. user.name , user.identity.name Fields with spaces in their name can may be encosed in double-quotes, e.g. \"user name\" , \"user.last name\" Quotes matters Enclosing a fields into single-quotes as 'some string' as a different meaning: see literal fields","title":"Syntax"},{"location":"fields/path/#examples","text":"","title":"Examples"},{"location":"fields/path/#generate-fields","text":"| make | eval userid = 'jdoe', user.name = 'John', user.lastname = 'Doe', \"user.twitter account\" = \"@JDoe\", user.loc = list(1, 2, 3) { \"userid\": \"jdoe\", \"user\": { \"name\": \"John\", \"lastname\": \"Doe\", \"twitter account\": \"@JDoe\" } }","title":"Generate fields"},{"location":"fields/pipe/","text":"Pipeline fields Pipeline fields returns the result of a sub-pipeline. They are similar to some programming languages functions . Syntax Pipelines fields are literal pipelines: | make count=3 | output format=[ | make | eval format='json' ] Pipeline fields output As most commands attributes excepts a single value or a list of values, the pipeline fields post-process their result. If the pipeline yields a single event and if this single event contains a single field, then the pipeline field return this single value. Otherwise, the latest event is returned whole.","title":"Pipeline"},{"location":"fields/pipe/#pipeline-fields","text":"Pipeline fields returns the result of a sub-pipeline. They are similar to some programming languages functions .","title":"Pipeline fields"},{"location":"fields/pipe/#syntax","text":"Pipelines fields are literal pipelines: | make count=3 | output format=[ | make | eval format='json' ] Pipeline fields output As most commands attributes excepts a single value or a list of values, the pipeline fields post-process their result. If the pipeline yields a single event and if this single event contains a single field, then the pipeline field return this single value. Otherwise, the latest event is returned whole.","title":"Syntax"},{"location":"mains/","text":"Mains The M42PL core package comes with different mains , aka. entry points to runs your pipelines. repl : Runs M42PL as a REPL (interactive command interpreter) run : Runs a M42PL script grammar : Prints M42PL EBNF grammar parse : Parse a M42PL script","title":"Overview"},{"location":"mains/#mains","text":"The M42PL core package comes with different mains , aka. entry points to runs your pipelines. repl : Runs M42PL as a REPL (interactive command interpreter) run : Runs a M42PL script grammar : Prints M42PL EBNF grammar parse : Parse a M42PL script","title":"Mains"},{"location":"mains/grammar/","text":"Grammar Dumps the EBNF grammar of a command. m42pl grammar <command_name>","title":"Grammar debug"},{"location":"mains/grammar/#grammar","text":"Dumps the EBNF grammar of a command. m42pl grammar <command_name>","title":"Grammar"},{"location":"mains/parse/","text":"Parse Parses the given M42PL script. m42pl parse <source_file>","title":"Parsing debug"},{"location":"mains/parse/#parse","text":"Parses the given M42PL script. m42pl parse <source_file>","title":"Parse"},{"location":"mains/repl/","text":"REPL (legacy) Legacy M42PL REPL / interpreter. Replaced by the new repl2 .","title":"REPL (legacy)"},{"location":"mains/repl/#repl-legacy","text":"Legacy M42PL REPL / interpreter. Replaced by the new repl2 .","title":"REPL (legacy)"},{"location":"mains/repl2/","text":"REPL Runs M42PL as a REPL (interactive command interpreter). m42pl repl General usage Unlike a standard Shell, the M42PL read multiples lines at once; to execute the pipeline you typed, hit Escape then Enter When a pipeline is running, type Ctrl+c to stop it You can use the arrow keys to move in history and in the pipeline source The REPL automatically adds an output command to your pipeline if you didn't added a similar command; use another dispatcher ( -d <dipatcher name> ) such as local to avoid this behaviour Arguments Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments Builtins commands The REPL provides some builtins commands, not run by M42PL dispatcher. Builtin Description exit Exists the REPL modules Prints the list of loaded modules import <name> Imports the module <name> reload Reloads the imported modules help Prints help cd <path> Changes the working directory to <path> pwd Prints the current working directory Prompt customization You can change the prompt prefix using -p or --prefix to provide an HTML string. Some standard PS1 builtins are supported as well. Tip Do not forget to close the HTML tags, e.g. <bold>...</bold> Syntax Kind Description {w} PS1 builtin Replaced by the current working directory {u} PS1 builtin Replaced by the current user name <bold> HTML tag Write text in bold <color name> HTML tag Write text in the given color name","title":"REPL (interactive)"},{"location":"mains/repl2/#repl","text":"Runs M42PL as a REPL (interactive command interpreter). m42pl repl","title":"REPL"},{"location":"mains/repl2/#general-usage","text":"Unlike a standard Shell, the M42PL read multiples lines at once; to execute the pipeline you typed, hit Escape then Enter When a pipeline is running, type Ctrl+c to stop it You can use the arrow keys to move in history and in the pipeline source The REPL automatically adds an output command to your pipeline if you didn't added a similar command; use another dispatcher ( -d <dipatcher name> ) such as local to avoid this behaviour","title":"General usage"},{"location":"mains/repl2/#arguments","text":"Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments","title":"Arguments"},{"location":"mains/repl2/#builtins-commands","text":"The REPL provides some builtins commands, not run by M42PL dispatcher. Builtin Description exit Exists the REPL modules Prints the list of loaded modules import <name> Imports the module <name> reload Reloads the imported modules help Prints help cd <path> Changes the working directory to <path> pwd Prints the current working directory","title":"Builtins commands"},{"location":"mains/repl2/#prompt-customization","text":"You can change the prompt prefix using -p or --prefix to provide an HTML string. Some standard PS1 builtins are supported as well. Tip Do not forget to close the HTML tags, e.g. <bold>...</bold> Syntax Kind Description {w} PS1 builtin Replaced by the current working directory {u} PS1 builtin Replaced by the current user name <bold> HTML tag Write text in bold <color name> HTML tag Write text in the given color name","title":"Prompt customization"},{"location":"mains/run/","text":"Run Runs a M42PL pipeline from a file. m42pl run <source_file> Arguments Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments","title":"Script"},{"location":"mains/run/#run","text":"Runs a M42PL pipeline from a file. m42pl run <source_file>","title":"Run"},{"location":"mains/run/#arguments","text":"Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments","title":"Arguments"},{"location":"quickstart/firststeps/","text":"First Steps Start the command line Once M42PL is installed (see the installation instructions ), you may run it in REPL (interactive) mode: If installed locally: m42pl repl If installed locally in a virtual environement: source m42pl/bin/activate m42pl repl If installed using Docker: docker run -it jpclipffel/m42pl repl Command line usage Multiline input The M42PL REPL runs in multi-line input mode by default, which means than pressing Enter will literally add a new line. To execute commands in multiline, press Esc then Enter To disable the multi-line input, type ml off To switch the multi-line input, type ml or ml on or ml off The M42PL language is extremelly simple: A program / script is a list of commands A command starts with the pipe | character A command may takes argument(s) (also known as fields ) This is an Hello World example: | eval hello='world' At any point, you may run a builtin : help : Display a quick REPL help exit : Quit the REPL You can get a list of available commands by running the commands command: | commands Lets keep only the fields we're interested in, namely command.alias and command.about : | commands | fields command.alias, command.about You may notice that some duplicates command.about appears; this is because many commands have aliases , i.e. multiple names. To regroup the command which have the same description, you may use stats : | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about Finally, to generate a nice single-line description of each command, it aliases and its description: | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about | eval man = join(aliases, ', ') + ': ' + command.about | fields man Events M42PL works with events . An event is a single unit of information, which contains one or more fields . You can think of an event as a JSON or YAML document, as a Python's dict (which they are), as a C/C++ structure, etc. Events are generated by Generating commands and processed by Streaming commands & Buffering commands . Commands M42PL support 4 types of commands: Generating commands generates events There is a single generating command per pipeline Generating command are usually put first in the pipeline A pipeline may include sub-pipelines, each of them may include a genrating command Generating commands may be piped into streaming commands , buffering commands and meta commands Streaming commands process events Each streaming command may be piped into another streaming command , buffering command or meta command Buffering commands process block of events Each buffering command may be piped into another buffering command , streaming command or meta command Meta commands forwards the data and manipulates the pipeline itself Each metacommand may be piped into another meta command , streaming command or buffering command Fields Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield JsonPath : A JsonPath expression, e.g. {list[0].name} Eval : An evaulation expression, e.g. at(list, 0) Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ]","title":"First steps"},{"location":"quickstart/firststeps/#first-steps","text":"","title":"First Steps"},{"location":"quickstart/firststeps/#start-the-command-line","text":"Once M42PL is installed (see the installation instructions ), you may run it in REPL (interactive) mode: If installed locally: m42pl repl If installed locally in a virtual environement: source m42pl/bin/activate m42pl repl If installed using Docker: docker run -it jpclipffel/m42pl repl","title":"Start the command line"},{"location":"quickstart/firststeps/#command-line-usage","text":"Multiline input The M42PL REPL runs in multi-line input mode by default, which means than pressing Enter will literally add a new line. To execute commands in multiline, press Esc then Enter To disable the multi-line input, type ml off To switch the multi-line input, type ml or ml on or ml off The M42PL language is extremelly simple: A program / script is a list of commands A command starts with the pipe | character A command may takes argument(s) (also known as fields ) This is an Hello World example: | eval hello='world' At any point, you may run a builtin : help : Display a quick REPL help exit : Quit the REPL You can get a list of available commands by running the commands command: | commands Lets keep only the fields we're interested in, namely command.alias and command.about : | commands | fields command.alias, command.about You may notice that some duplicates command.about appears; this is because many commands have aliases , i.e. multiple names. To regroup the command which have the same description, you may use stats : | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about Finally, to generate a nice single-line description of each command, it aliases and its description: | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about | eval man = join(aliases, ', ') + ': ' + command.about | fields man","title":"Command line usage"},{"location":"quickstart/firststeps/#events","text":"M42PL works with events . An event is a single unit of information, which contains one or more fields . You can think of an event as a JSON or YAML document, as a Python's dict (which they are), as a C/C++ structure, etc. Events are generated by Generating commands and processed by Streaming commands & Buffering commands .","title":"Events"},{"location":"quickstart/firststeps/#commands","text":"M42PL support 4 types of commands: Generating commands generates events There is a single generating command per pipeline Generating command are usually put first in the pipeline A pipeline may include sub-pipelines, each of them may include a genrating command Generating commands may be piped into streaming commands , buffering commands and meta commands Streaming commands process events Each streaming command may be piped into another streaming command , buffering command or meta command Buffering commands process block of events Each buffering command may be piped into another buffering command , streaming command or meta command Meta commands forwards the data and manipulates the pipeline itself Each metacommand may be piped into another meta command , streaming command or buffering command","title":"Commands"},{"location":"quickstart/firststeps/#fields","text":"Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield JsonPath : A JsonPath expression, e.g. {list[0].name} Eval : An evaulation expression, e.g. at(list, 0) Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ]","title":"Fields"},{"location":"quickstart/installation/","text":"Installation M42PL is divided into several packages and repositories. If you're starting on the project, you may prefer to use a container image . For more experienced users and developers, you may install the project from source . Container images Two container images are available: jpclipffel/m42pl : standard image, comes with everything pre-installed docker pull jpclipffel/m42pl:latest # Or docker pull ghcr.io/jpclipffel/m42pl:latest jpclipffel/m42pl-core : base image, contains only m42pl-core docker pull jpclipffel/m42pl-core:latest # Or docker pull ghcr.io/jpclipffel/m42pl-core:latest From source M42PL is built on several components ( core , commands , dispatchers , kvstores and encoders ). Installation in a virtual environment If is recomended to install M42PL into a dedicated virtual environement: python -m venv m42pl && source m42pl/bin/activate Installation in development mode If you plan to make change to M42PL, install the component(s) with pip install -e <component> Install the core project m42pl_core : git clone https://github.com/jpclipffel/m42pl-core pip install m42pl-core Install the core commands m42pl_commands : git clone https://github.com/jpclipffel/m42pl-commands pip install m42pl-commands Install the core dispatchers m42pl_dispatchers : git clone https://github.com/jpclipffel/m42pl-dispatchers pip install m42pl-dispatchers Install the core kvstores m42pl_kvsotres : git clone https://github.com/jpclipffel/m42pl-kvstores pip install m42pl-kvstores Install the core encoders m42pl_encoders : git clone https://github.com/jpclipffel/m42pl-encoders pip install m42pl-encoders","title":"Installation"},{"location":"quickstart/installation/#installation","text":"M42PL is divided into several packages and repositories. If you're starting on the project, you may prefer to use a container image . For more experienced users and developers, you may install the project from source .","title":"Installation"},{"location":"quickstart/installation/#container-images","text":"Two container images are available: jpclipffel/m42pl : standard image, comes with everything pre-installed docker pull jpclipffel/m42pl:latest # Or docker pull ghcr.io/jpclipffel/m42pl:latest jpclipffel/m42pl-core : base image, contains only m42pl-core docker pull jpclipffel/m42pl-core:latest # Or docker pull ghcr.io/jpclipffel/m42pl-core:latest","title":" Container images"},{"location":"quickstart/installation/#from-source","text":"M42PL is built on several components ( core , commands , dispatchers , kvstores and encoders ). Installation in a virtual environment If is recomended to install M42PL into a dedicated virtual environement: python -m venv m42pl && source m42pl/bin/activate Installation in development mode If you plan to make change to M42PL, install the component(s) with pip install -e <component> Install the core project m42pl_core : git clone https://github.com/jpclipffel/m42pl-core pip install m42pl-core Install the core commands m42pl_commands : git clone https://github.com/jpclipffel/m42pl-commands pip install m42pl-commands Install the core dispatchers m42pl_dispatchers : git clone https://github.com/jpclipffel/m42pl-dispatchers pip install m42pl-dispatchers Install the core kvstores m42pl_kvsotres : git clone https://github.com/jpclipffel/m42pl-kvstores pip install m42pl-kvstores Install the core encoders m42pl_encoders : git clone https://github.com/jpclipffel/m42pl-encoders pip install m42pl-encoders","title":" From source"}]}