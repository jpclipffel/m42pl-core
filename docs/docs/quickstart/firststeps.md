<!-- vim: set ft=Markdown ts=4 -->

# First Steps

## Start the command line

Once M42PL is installed (see the [installation instructions][install]), you may
run it in REPL (interactive) mode:

If installed locally:

```shell
m42pl repl
```

If installed locally in a virtual environement:

```shell
source m42pl/bin/activate
m42pl repl
```

If installed using Docker:

```shell
docker run -it jpclipffel/m42pl repl
```

## Command line usage

!!! note "Multiline input"
    The M42PL REPL runs in multi-line input mode by default, which means than
    pressing `Enter` will literally add a new line.

    - To execute commands in multiline, press `Esc` then `Enter`
    - To disable the multi-line input, type `ml off`
    - To switch the multi-line input, type `ml` or `ml on` or `ml off`

The M42PL language is extremelly simple:

* A program / script is a list of _commands_
* A command starts with the pipe `|` character
* A command may takes _argument(s)_ (also known as _fields_)

This is an _Hello World_ example:

```
| eval hello='world'
```

At any point, you may run a _builtin_:

* `help`: Display a quick REPL help
* `exit`: Quit the REPL

You can get a list of available commands by running the `commands` command:

```
| commands
```

Lets keep only the fields we're interested in, namely `command.alias`
and `command.about`:

```
| commands
| fields command.alias, command.about
```

You may notice that some duplicates `command.about` appears; this is because
many commands have _aliases_, i.e. multiple names.

To regroup the command which have the same description, you may use `stats`:

```
| commands
| fields command.alias, command.about
| stats values(command.alias) as aliases by command.about
```

Finally, to generate a nice single-line description of each command, it aliases
and its description:

```
| commands
| fields command.alias, command.about
| stats values(command.alias) as aliases by command.about
| eval man = join(aliases, ', ') + ': ' + command.about
| fields man
```

## Events

M42PL works with _events_. An event is a single unit of information, which
contains one or more _fields_.

You can think of an event as a JSON or YAML document, as a Python's `dict`
(which they are), as a C/C++ structure, etc.

Events are generated by _Generating commands_ and processed by
_Streaming commands_ & _Buffering commands_.

## Commands

M42PL support 4 types of commands:

* _Generating commands_ generates events
    * There is a single _generating command_ per pipeline
    * _Generating command_ are usually put first in the pipeline
    * A pipeline may include sub-pipelines, each of them may include a _genrating command_
    * _Generating commands_ may be _piped_ into _streaming commands_, _buffering commands_ and _meta commands_
* _Streaming commands_ process events
    * Each _streaming command_ may be _piped_ into another _streaming command_, _buffering command_ or _meta command_
* _Buffering commands_ process block of events
    * Each _buffering command_ may be _piped_ into another _buffering command_, _streaming command_ or _meta command_
* _Meta commands_ forwards the data and manipulates the pipeline itself
    * Each _metacommand_ may be _piped_ into another _meta command_, _streaming command_ or _buffering command_

## Fields

Fields are both the events _attributes_ and a way to access the given _attributes_.

M42PL's commands support 5 type of fields:

* _Literal_: A literal value such as a number, a string or a list of values, e.g. `42`, `'some text'`, `(1, 2, 3)`
* _Path_: A field name or a doted field name, e.g. `field`, `field.subfield`
* _JsonPath_: A _JsonPath_ expression, e.g. `{list[0].name}`
* _Eval_: An evaulation expression, e.g. ```at(list, 0)```
* _Pipe_: A sub-pipeline, e.g. `[ | kvread 'someName' ]`

---

[install]: installation.md
