{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"M42PL - A Data Manipulation Language M42PL is a Data Manipulation Language , inspired by Unix shells and Splunk . The language is extremely simple to learn and to use. It is designed to make data manipulation trivial, even for non-technical users. Examples Query an URL | url 'https://api.ipify.org' | fields response.content, response.status | eval message = 'Your external IP is ' + response.content Run a HTTP server | http_server with '*' on '/foo' = [ | echo | eval path='foo', mode='infinite+iterator' | fields path, mode ], '*' on '/bar' = [ | eval path='bar', mode='infinite+stream' | fields path, mode ], '*' on '/{path}' = [] Capture and stream a video This requires the installation of m42pl-vision | cv2_read | cv2_resize ratio=0.5 | zmq_pub topic='webcam' Display a video stream This requires the installation of m42pl-vision | zmq_sub topic='webcam' | decode {zmq.frames[0]} with 'msgpack' | cv2_show cv2.frame","title":"Home"},{"location":"#m42pl-a-data-manipulation-language","text":"M42PL is a Data Manipulation Language , inspired by Unix shells and Splunk . The language is extremely simple to learn and to use. It is designed to make data manipulation trivial, even for non-technical users.","title":"M42PL - A Data Manipulation Language"},{"location":"#examples","text":"Query an URL | url 'https://api.ipify.org' | fields response.content, response.status | eval message = 'Your external IP is ' + response.content Run a HTTP server | http_server with '*' on '/foo' = [ | echo | eval path='foo', mode='infinite+iterator' | fields path, mode ], '*' on '/bar' = [ | eval path='bar', mode='infinite+stream' | fields path, mode ], '*' on '/{path}' = [] Capture and stream a video This requires the installation of m42pl-vision | cv2_read | cv2_resize ratio=0.5 | zmq_pub topic='webcam' Display a video stream This requires the installation of m42pl-vision | zmq_sub topic='webcam' | decode {zmq.frames[0]} with 'msgpack' | cv2_show cv2.frame","title":"Examples"},{"location":"components/","text":"Components M42PL is built on 5 kind of components, each of them providing a set of core functionnalities and each of them being extendable and replacable. Core : The core project Commands : The language commands and constructs KVStores : The key-value interfaces Encoders : The data encoding/decoding codecs Dispatchers : The pipelines runners/executors/schedulers/...","title":"Overview"},{"location":"components/#components","text":"M42PL is built on 5 kind of components, each of them providing a set of core functionnalities and each of them being extendable and replacable. Core : The core project Commands : The language commands and constructs KVStores : The key-value interfaces Encoders : The data encoding/decoding codecs Dispatchers : The pipelines runners/executors/schedulers/...","title":"Components"},{"location":"components/commands/","text":"Commands To do.","title":"Commands"},{"location":"components/commands/#commands","text":"To do.","title":"Commands"},{"location":"components/core/","text":"Core To do.","title":"Core"},{"location":"components/core/#core","text":"To do.","title":"Core"},{"location":"components/dispatchers/","text":"Dispatchers To do.","title":"Dispatchers"},{"location":"components/dispatchers/#dispatchers","text":"To do.","title":"Dispatchers"},{"location":"components/encoders/","text":"Dispatchers To do.","title":"Encoders"},{"location":"components/encoders/#dispatchers","text":"To do.","title":"Dispatchers"},{"location":"components/kvstores/","text":"KVStores To do.","title":"KVStores"},{"location":"components/kvstores/#kvstores","text":"To do.","title":"KVStores"},{"location":"fields/","text":"Fields Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield Eval : An evaulation expression, e.g. at(list, 0) JsonPath : A JsonPath expression, e.g. {list[0].name} Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ] Fields interpretation It is important to note that fields values are dynamic while fields types are static . M42PL decides which field functor has to be instanciated using the field syntax. For example, the field {user.emails[0]} is matched as a JsonPath field. Each time an event is processed, the same JsonPath instance will be called with the event as first parameter to extrat the first item ( [0] ) in the list emails in the root field user . Literal fields Although literal fields always return the same value, they are also implemented as functors in M42PL.","title":"Overview"},{"location":"fields/#fields","text":"Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield Eval : An evaulation expression, e.g. at(list, 0) JsonPath : A JsonPath expression, e.g. {list[0].name} Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ]","title":"Fields"},{"location":"fields/#fields-interpretation","text":"It is important to note that fields values are dynamic while fields types are static . M42PL decides which field functor has to be instanciated using the field syntax. For example, the field {user.emails[0]} is matched as a JsonPath field. Each time an event is processed, the same JsonPath instance will be called with the event as first parameter to extrat the first item ( [0] ) in the list emails in the root field user . Literal fields Although literal fields always return the same value, they are also implemented as functors in M42PL.","title":"Fields interpretation"},{"location":"fields/eval/","text":"Evaluated fields Evaluated fields returns the result of an evaluation expression . They are similar to some programming languages lambdas . Syntax Evaluated fields are enclosed in back-quotes: current_year=`strftime(now(), '%Y')` Example Write the output of the command ps aux in files, with on file per user name. Script: | process 'ps' 'aux' | regex line with '(?P<user>[^\\s]+).*' | writefile `line + '\\n'` to `'/tmp/processes-' + user + '.log'` Generated files (truncated output): ls -l /tmp/processes-* -rw-rw-r-- 1 ... /tmp/processes-avahi.log -rw-rw-r-- 1 ... /tmp/processes-colord.log -rw-rw-r-- 1 ... /tmp/processes-message+.log -rw-rw-r-- 1 ... /tmp/processes-root.log -rw-rw-r-- 1 ... /tmp/processes-syslog.log -rw-rw-r-- 1 ... /tmp/processes-systemd+.log -rw-rw-r-- 1 ... /tmp/processes-USER.log -rw-rw-r-- 1 ... /tmp/processes-uuidd.log","title":"Evaluated"},{"location":"fields/eval/#evaluated-fields","text":"Evaluated fields returns the result of an evaluation expression . They are similar to some programming languages lambdas .","title":"Evaluated fields"},{"location":"fields/eval/#syntax","text":"Evaluated fields are enclosed in back-quotes: current_year=`strftime(now(), '%Y')`","title":"Syntax"},{"location":"fields/eval/#example","text":"Write the output of the command ps aux in files, with on file per user name. Script: | process 'ps' 'aux' | regex line with '(?P<user>[^\\s]+).*' | writefile `line + '\\n'` to `'/tmp/processes-' + user + '.log'` Generated files (truncated output): ls -l /tmp/processes-* -rw-rw-r-- 1 ... /tmp/processes-avahi.log -rw-rw-r-- 1 ... /tmp/processes-colord.log -rw-rw-r-- 1 ... /tmp/processes-message+.log -rw-rw-r-- 1 ... /tmp/processes-root.log -rw-rw-r-- 1 ... /tmp/processes-syslog.log -rw-rw-r-- 1 ... /tmp/processes-systemd+.log -rw-rw-r-- 1 ... /tmp/processes-USER.log -rw-rw-r-- 1 ... /tmp/processes-uuidd.log","title":"Example"},{"location":"fields/jsonpath/","text":"JsonPath fields JsonPath fields extract a field's value from an event using a JsonPath expression. JsonPath syntax reference: https://pypi.org/project/jsonpath-ng/ https://goessner.net/articles/JsonPath/ Syntax JsonPath fields are enclosed in brackets: field={a.b.c[0]} Example | make | eval mpl.encoders = list('raw', 'json') | rename {mpl.encoders[0]} as encoders {mpl.encoders[0]} is a JsonPath expression which selects the first item ( [0] ) of the nested field encoders in the root field mpl . { \"mpl\": { \"encoders\": [ \"json\" ] }, \"encoders\": \"raw\" }","title":"JsonPath"},{"location":"fields/jsonpath/#jsonpath-fields","text":"JsonPath fields extract a field's value from an event using a JsonPath expression. JsonPath syntax reference: https://pypi.org/project/jsonpath-ng/ https://goessner.net/articles/JsonPath/","title":"JsonPath fields"},{"location":"fields/jsonpath/#syntax","text":"JsonPath fields are enclosed in brackets: field={a.b.c[0]}","title":"Syntax"},{"location":"fields/jsonpath/#example","text":"| make | eval mpl.encoders = list('raw', 'json') | rename {mpl.encoders[0]} as encoders {mpl.encoders[0]} is a JsonPath expression which selects the first item ( [0] ) of the nested field encoders in the root field mpl . { \"mpl\": { \"encoders\": [ \"json\" ] }, \"encoders\": \"raw\" }","title":"Example"},{"location":"fields/literal/","text":"Literal fields Literal fields are literal values, which are not read from the events. You can use literal fields to configure static commands values. Syntax Strings are enclosed in simple quotes , e.g. 'a string' Numbers (integer or floats) are written as-is, e.g. 42 , 21.42 Quotes matters Enclosing a string into double-quotes as \"some string\" as a different meaning: see path fields Examples Generate 2 events | make count=2 2 is a literal value, interpreted as in integer {} {} Query an URL | url 'https://api.ipify.org' 'https://api.ipify.org' is a literal value, interpreted as a string { \"time\": 1234, \"request\": { \"method\": \"GET\", \"url\": \"https://api.ipify.org\", \"headers\": {}, \"data\": {} }, \"response\": { \"status\": 200, \"reason\": \"OK\", \"mime\": { \"type\": \"text/plain\" }, \"headers\": { \"Server\": \"Cowboy\", \"Connection\": \"keep-alive\", \"Content-Type\": \"text/plain\", \"Vary\": \"Origin\", \"Date\": \"....\", \"Content-Length\": \"13\", \"Via\": \"1.1 vegur\" }, \"content\": \"...\" } }","title":"Literal"},{"location":"fields/literal/#literal-fields","text":"Literal fields are literal values, which are not read from the events. You can use literal fields to configure static commands values.","title":"Literal fields"},{"location":"fields/literal/#syntax","text":"Strings are enclosed in simple quotes , e.g. 'a string' Numbers (integer or floats) are written as-is, e.g. 42 , 21.42 Quotes matters Enclosing a string into double-quotes as \"some string\" as a different meaning: see path fields","title":"Syntax"},{"location":"fields/literal/#examples","text":"","title":"Examples"},{"location":"fields/literal/#generate-2-events","text":"| make count=2 2 is a literal value, interpreted as in integer {} {}","title":"Generate 2 events"},{"location":"fields/literal/#query-an-url","text":"| url 'https://api.ipify.org' 'https://api.ipify.org' is a literal value, interpreted as a string { \"time\": 1234, \"request\": { \"method\": \"GET\", \"url\": \"https://api.ipify.org\", \"headers\": {}, \"data\": {} }, \"response\": { \"status\": 200, \"reason\": \"OK\", \"mime\": { \"type\": \"text/plain\" }, \"headers\": { \"Server\": \"Cowboy\", \"Connection\": \"keep-alive\", \"Content-Type\": \"text/plain\", \"Vary\": \"Origin\", \"Date\": \"....\", \"Content-Length\": \"13\", \"Via\": \"1.1 vegur\" }, \"content\": \"...\" } }","title":"Query an URL"},{"location":"fields/path/","text":"Path fields Path fields are event's attributes names, which may use a dotted notattion (e.g. some.field.name ) to represent nested events fields. Syntax Root fields are written as-in, e.g. fieldName Nested fields are sperated by a dot, e.g. user.name , user.identity.name Fields with spaces in their name can may be encosed in double-quotes, e.g. \"user name\" , \"user.last name\" Quotes matters Enclosing a fields into single-quotes as 'some string' as a different meaning: see literal fields Examples Generate fields | make | eval userid = 'jdoe', user.name = 'John', user.lastname = 'Doe', \"user.twitter account\" = \"@JDoe\", user.loc = list(1, 2, 3) { \"userid\": \"jdoe\", \"user\": { \"name\": \"John\", \"lastname\": \"Doe\", \"twitter account\": \"@JDoe\" } }","title":"Path"},{"location":"fields/path/#path-fields","text":"Path fields are event's attributes names, which may use a dotted notattion (e.g. some.field.name ) to represent nested events fields.","title":"Path fields"},{"location":"fields/path/#syntax","text":"Root fields are written as-in, e.g. fieldName Nested fields are sperated by a dot, e.g. user.name , user.identity.name Fields with spaces in their name can may be encosed in double-quotes, e.g. \"user name\" , \"user.last name\" Quotes matters Enclosing a fields into single-quotes as 'some string' as a different meaning: see literal fields","title":"Syntax"},{"location":"fields/path/#examples","text":"","title":"Examples"},{"location":"fields/path/#generate-fields","text":"| make | eval userid = 'jdoe', user.name = 'John', user.lastname = 'Doe', \"user.twitter account\" = \"@JDoe\", user.loc = list(1, 2, 3) { \"userid\": \"jdoe\", \"user\": { \"name\": \"John\", \"lastname\": \"Doe\", \"twitter account\": \"@JDoe\" } }","title":"Generate fields"},{"location":"fields/pipe/","text":"Pipeline fields Pipeline fields returns the result of a sub-pipeline. They are similar to some programming languages functions . Syntax Pipelines fields are literal pipelines: | make count=3 | output format=[ | make | eval format='json' ] Pipeline fields output As most commands attributes excepts a single value or a list of values, the pipeline fields post-process their result. If the pipeline yields a single event and if this single event contains a single field, then the pipeline field return this single value. Otherwise, the latest event is returned whole.","title":"Pipeline"},{"location":"fields/pipe/#pipeline-fields","text":"Pipeline fields returns the result of a sub-pipeline. They are similar to some programming languages functions .","title":"Pipeline fields"},{"location":"fields/pipe/#syntax","text":"Pipelines fields are literal pipelines: | make count=3 | output format=[ | make | eval format='json' ] Pipeline fields output As most commands attributes excepts a single value or a list of values, the pipeline fields post-process their result. If the pipeline yields a single event and if this single event contains a single field, then the pipeline field return this single value. Otherwise, the latest event is returned whole.","title":"Syntax"},{"location":"idioms/","text":"Idioms This chapter documents typicall M42PL patterns. Pipelines structure Parallelization Encoding and decoding","title":"Overview"},{"location":"idioms/#idioms","text":"This chapter documents typicall M42PL patterns. Pipelines structure Parallelization Encoding and decoding","title":"Idioms"},{"location":"idioms/encoding_decoding/","text":"Encoding and decoding M42PL process events , which conveys any kind of data: text, number, bytes, etc. Although events can be constructed from nearly anything, it may be required to decode a source payload to work on it, and to encode an event or an event field to pass it to another system. Codecs The command codecs yields the available codecs , i.e. data encoders and decoders. You can use the codec' alias in the encode and decode commands. | codecs Example output: { \"codec\": { \"alias\": \"json\", \"about\": \"Support for JSON text format\" } } { \"codec\": { \"alias\": \"hjson\", \"about\": \"Support for colored JSON text format\" } } { \"codec\": { \"alias\": \"msgpack\", \"about\": \"Support for MsgPack binary format\" } } Encoding The encode command encodes an event or an event field with the given codec . Encode an event Script: | make showinfo=yes | encode dest='json' codec='json' | fields json Variant syntax: | make showinfo=yes | encode as json with 'json' | fields json Output: { \"json\": \"{\\\"id\\\": 0, \\\"chunk\\\": {\\\"chunk\\\": 0, \\\"chunks\\\": 1}, \\\"count\\\": {\\\"begin\\\": 0, \\\"end\\\": 1}, \\\"pipeline\\\": {\\\"name\\\": \\\"main\\\"}}\" } Encode a field Script: | make showinfo=yes | encode src=pipeline dest=json codec='json' | fields json Variant syntax: | make showinfo=yes | encode pipeline as json with 'json' | fields json Output: { \"json\": \"{\\\"pipeline\\\": {\\\"name\\\": \\\"main\\\"}}\" } Decoding The decode command decodes an event field with the given codec . Examples are examples The next example is trivial; a real world use case could be to send events through a socket or a queue system such as ZeroMQ, but this is out of this document scope. First, lets created a msgpack -encoded field and get the encoded value: | make showinfo=yes | encode with 'msgpack' | fields encoded Then, lets decode the field encoded with the proper codec and keep only the decoded event: | decode \"encoded\" with msgpack | fields - encoded Output: { \"id\": 0, \"chunk\": { \"chunk\": 0, \"chunks\": 1 }, \"count\": { \"begin\": 0, \"end\": 1 }, \"pipeline\": { \"name\": \"main\" } } Complete script for reference: | make showinfo=yes | encode with 'msgpack' | fields encoded | decode \"encoded\" with msgpack | fields - encoded","title":"Encoding & Decoding"},{"location":"idioms/encoding_decoding/#encoding-and-decoding","text":"M42PL process events , which conveys any kind of data: text, number, bytes, etc. Although events can be constructed from nearly anything, it may be required to decode a source payload to work on it, and to encode an event or an event field to pass it to another system.","title":"Encoding and decoding"},{"location":"idioms/encoding_decoding/#codecs","text":"The command codecs yields the available codecs , i.e. data encoders and decoders. You can use the codec' alias in the encode and decode commands. | codecs Example output: { \"codec\": { \"alias\": \"json\", \"about\": \"Support for JSON text format\" } } { \"codec\": { \"alias\": \"hjson\", \"about\": \"Support for colored JSON text format\" } } { \"codec\": { \"alias\": \"msgpack\", \"about\": \"Support for MsgPack binary format\" } }","title":"Codecs"},{"location":"idioms/encoding_decoding/#encoding","text":"The encode command encodes an event or an event field with the given codec .","title":"Encoding"},{"location":"idioms/encoding_decoding/#encode-an-event","text":"Script: | make showinfo=yes | encode dest='json' codec='json' | fields json Variant syntax: | make showinfo=yes | encode as json with 'json' | fields json Output: { \"json\": \"{\\\"id\\\": 0, \\\"chunk\\\": {\\\"chunk\\\": 0, \\\"chunks\\\": 1}, \\\"count\\\": {\\\"begin\\\": 0, \\\"end\\\": 1}, \\\"pipeline\\\": {\\\"name\\\": \\\"main\\\"}}\" }","title":"Encode an event"},{"location":"idioms/encoding_decoding/#encode-a-field","text":"Script: | make showinfo=yes | encode src=pipeline dest=json codec='json' | fields json Variant syntax: | make showinfo=yes | encode pipeline as json with 'json' | fields json Output: { \"json\": \"{\\\"pipeline\\\": {\\\"name\\\": \\\"main\\\"}}\" }","title":"Encode a field"},{"location":"idioms/encoding_decoding/#decoding","text":"The decode command decodes an event field with the given codec . Examples are examples The next example is trivial; a real world use case could be to send events through a socket or a queue system such as ZeroMQ, but this is out of this document scope. First, lets created a msgpack -encoded field and get the encoded value: | make showinfo=yes | encode with 'msgpack' | fields encoded Then, lets decode the field encoded with the proper codec and keep only the decoded event: | decode \"encoded\" with msgpack | fields - encoded Output: { \"id\": 0, \"chunk\": { \"chunk\": 0, \"chunks\": 1 }, \"count\": { \"begin\": 0, \"end\": 1 }, \"pipeline\": { \"name\": \"main\" } } Complete script for reference: | make showinfo=yes | encode with 'msgpack' | fields encoded | decode \"encoded\" with msgpack | fields - encoded","title":"Decoding"},{"location":"idioms/parallelization/","text":"Parallelization M42PL provides two mechanisms to parallelize the pipelines: Implicit : Parallelization is handled by the selected dispatcher , which control the pipelines structure to make them run on multiples CPU, nodes, etc. Explicit : On the top of the dispatcher, some commands allow to split and merge the pipelines. Split a pipeline A pipeline can be split in multiples sub-pipelines using the parallel (or tee ) command. | make count=10 showinfo=yes | parallel [ | eval p=1 | stats count by p ], [ | eval p=2 | stats max(id) by p ] Output: { \"p\": 1, \"count()\": 10 } { \"p\": 2, \"max(id)\": 9 }","title":"Parallelization"},{"location":"idioms/parallelization/#parallelization","text":"M42PL provides two mechanisms to parallelize the pipelines: Implicit : Parallelization is handled by the selected dispatcher , which control the pipelines structure to make them run on multiples CPU, nodes, etc. Explicit : On the top of the dispatcher, some commands allow to split and merge the pipelines.","title":"Parallelization"},{"location":"idioms/parallelization/#split-a-pipeline","text":"A pipeline can be split in multiples sub-pipelines using the parallel (or tee ) command. | make count=10 showinfo=yes | parallel [ | eval p=1 | stats count by p ], [ | eval p=2 | stats max(id) by p ] Output: { \"p\": 1, \"count()\": 10 } { \"p\": 2, \"max(id)\": 9 }","title":"Split a pipeline"},{"location":"idioms/pipelines_structure/","text":"Pipelines structure Pipelines begining A pipeline should always begins with a generating command . Although the pipelines runners allows to start with a streaming command , this is to be considered as a syntatic sugar. The echo command yields either the previous event or an empty one: | echo","title":"Structure"},{"location":"idioms/pipelines_structure/#pipelines-structure","text":"","title":"Pipelines structure"},{"location":"idioms/pipelines_structure/#pipelines-begining","text":"A pipeline should always begins with a generating command . Although the pipelines runners allows to start with a streaming command , this is to be considered as a syntatic sugar. The echo command yields either the previous event or an empty one: | echo","title":"Pipelines begining"},{"location":"mains/","text":"Mains The M42PL core package comes with different mains , aka. entry points to runs your pipelines. repl : Runs M42PL as a REPL (interactive command interpreter) run : Runs a M42PL script grammar : Prints M42PL EBNF grammar parse : Parse a M42PL script","title":"Overview"},{"location":"mains/#mains","text":"The M42PL core package comes with different mains , aka. entry points to runs your pipelines. repl : Runs M42PL as a REPL (interactive command interpreter) run : Runs a M42PL script grammar : Prints M42PL EBNF grammar parse : Parse a M42PL script","title":"Mains"},{"location":"mains/grammar/","text":"Grammar Dumps the EBNF grammar of a command. m42pl grammar <command_name>","title":"Grammar debug"},{"location":"mains/grammar/#grammar","text":"Dumps the EBNF grammar of a command. m42pl grammar <command_name>","title":"Grammar"},{"location":"mains/parse/","text":"Parse Parses the given M42PL script. m42pl parse <source_file>","title":"Parsing debug"},{"location":"mains/parse/#parse","text":"Parses the given M42PL script. m42pl parse <source_file>","title":"Parse"},{"location":"mains/repl/","text":"REPL (legacy) Legacy M42PL REPL / interpreter. Replaced by the new repl2 .","title":"REPL (legacy)"},{"location":"mains/repl/#repl-legacy","text":"Legacy M42PL REPL / interpreter. Replaced by the new repl2 .","title":"REPL (legacy)"},{"location":"mains/repl2/","text":"REPL Runs M42PL as a REPL (interactive command interpreter). m42pl repl General usage Unlike a standard Shell, the M42PL read multiples lines at once; to execute the pipeline you typed, hit Escape then Enter When a pipeline is running, type Ctrl+c to stop it You can use the arrow keys to move in history and in the pipeline source The REPL automatically adds an output command to your pipeline if you didn't added a similar command; use another dispatcher ( -d <dipatcher name> ) such as local to avoid this behaviour Arguments Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments Builtins commands The REPL provides some builtins commands, not run by M42PL dispatcher. Builtin Description exit Exists the REPL modules Prints the list of loaded modules import <name> Imports the module <name> reload Reloads the imported modules help Prints help cd <path> Changes the working directory to <path> pwd Prints the current working directory Prompt customization You can change the prompt prefix using -p or --prefix to provide an HTML string. Some standard PS1 builtins are supported as well. Tip Do not forget to close the HTML tags, e.g. <bold>...</bold> Syntax Kind Description {w} PS1 builtin Replaced by the current working directory {u} PS1 builtin Replaced by the current user name <bold> HTML tag Write text in bold <color name> HTML tag Write text in the given color name","title":"REPL (interactive)"},{"location":"mains/repl2/#repl","text":"Runs M42PL as a REPL (interactive command interpreter). m42pl repl","title":"REPL"},{"location":"mains/repl2/#general-usage","text":"Unlike a standard Shell, the M42PL read multiples lines at once; to execute the pipeline you typed, hit Escape then Enter When a pipeline is running, type Ctrl+c to stop it You can use the arrow keys to move in history and in the pipeline source The REPL automatically adds an output command to your pipeline if you didn't added a similar command; use another dispatcher ( -d <dipatcher name> ) such as local to avoid this behaviour","title":"General usage"},{"location":"mains/repl2/#arguments","text":"Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments","title":"Arguments"},{"location":"mains/repl2/#builtins-commands","text":"The REPL provides some builtins commands, not run by M42PL dispatcher. Builtin Description exit Exists the REPL modules Prints the list of loaded modules import <name> Imports the module <name> reload Reloads the imported modules help Prints help cd <path> Changes the working directory to <path> pwd Prints the current working directory","title":"Builtins commands"},{"location":"mains/repl2/#prompt-customization","text":"You can change the prompt prefix using -p or --prefix to provide an HTML string. Some standard PS1 builtins are supported as well. Tip Do not forget to close the HTML tags, e.g. <bold>...</bold> Syntax Kind Description {w} PS1 builtin Replaced by the current working directory {u} PS1 builtin Replaced by the current user name <bold> HTML tag Write text in bold <color name> HTML tag Write text in the given color name","title":"Prompt customization"},{"location":"mains/run/","text":"Run Runs a M42PL pipeline from a file. m42pl run <source_file> Arguments Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments","title":"Script"},{"location":"mains/run/#run","text":"Runs a M42PL pipeline from a file. m42pl run <source_file>","title":"Run"},{"location":"mains/run/#arguments","text":"Tip Run m42pl repl -h or m42pl repl --help to get help TODO Document REPL arguments","title":"Arguments"},{"location":"quickstart/firststeps/","text":"First Steps Start the command line Once M42PL is installed (see the installation instructions ), you may run it in REPL (interactive) mode: If installed locally: m42pl repl If installed locally in a virtual environement: source m42pl/bin/activate m42pl repl If installed using Docker: docker run -it jpclipffel/m42pl repl Command line usage Multiline input The M42PL REPL runs in multi-line input mode by default, which means than pressing Enter will literally add a new line. To execute commands in multiline, press Esc then Enter To disable the multi-line input, type ml off To switch the multi-line input, type ml or ml on or ml off The M42PL language is extremelly simple: A program / script is a list of commands A command starts with the pipe | character A command may takes argument(s) (also known as fields ) This is an Hello World example: | eval hello='world' At any point, you may run a builtin : help : Display a quick REPL help exit : Quit the REPL You can get a list of available commands by running the commands command: | commands Lets keep only the fields we're interested in, namely command.alias and command.about : | commands | fields command.alias, command.about You may notice that some duplicates command.about appears; this is because many commands have aliases , i.e. multiple names. To regroup the command which have the same description, you may use stats : | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about Finally, to generate a nice single-line description of each command, it aliases and its description: | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about | eval man = join(aliases, ', ') + ': ' + command.about | fields man Events M42PL works with events . An event is a single unit of information, which contains one or more fields . You can think of an event as a JSON or YAML document, as a Python's dict (which they are), as a C/C++ structure, etc. Events are generated by Generating commands and processed by Streaming commands & Buffering commands . Commands M42PL support 4 types of commands: Generating commands generates events There is a single generating command per pipeline Generating command are usually put first in the pipeline A pipeline may include sub-pipelines, each of them may include a genrating command Generating commands may be piped into streaming commands , buffering commands and meta commands Streaming commands process events Each streaming command may be piped into another streaming command , buffering command or meta command Buffering commands process block of events Each buffering command may be piped into another buffering command , streaming command or meta command Meta commands forwards the data and manipulates the pipeline itself Each metacommand may be piped into another meta command , streaming command or buffering command Fields Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield JsonPath : A JsonPath expression, e.g. {list[0].name} Eval : An evaulation expression, e.g. at(list, 0) Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ]","title":"First steps"},{"location":"quickstart/firststeps/#first-steps","text":"","title":"First Steps"},{"location":"quickstart/firststeps/#start-the-command-line","text":"Once M42PL is installed (see the installation instructions ), you may run it in REPL (interactive) mode: If installed locally: m42pl repl If installed locally in a virtual environement: source m42pl/bin/activate m42pl repl If installed using Docker: docker run -it jpclipffel/m42pl repl","title":"Start the command line"},{"location":"quickstart/firststeps/#command-line-usage","text":"Multiline input The M42PL REPL runs in multi-line input mode by default, which means than pressing Enter will literally add a new line. To execute commands in multiline, press Esc then Enter To disable the multi-line input, type ml off To switch the multi-line input, type ml or ml on or ml off The M42PL language is extremelly simple: A program / script is a list of commands A command starts with the pipe | character A command may takes argument(s) (also known as fields ) This is an Hello World example: | eval hello='world' At any point, you may run a builtin : help : Display a quick REPL help exit : Quit the REPL You can get a list of available commands by running the commands command: | commands Lets keep only the fields we're interested in, namely command.alias and command.about : | commands | fields command.alias, command.about You may notice that some duplicates command.about appears; this is because many commands have aliases , i.e. multiple names. To regroup the command which have the same description, you may use stats : | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about Finally, to generate a nice single-line description of each command, it aliases and its description: | commands | fields command.alias, command.about | stats values(command.alias) as aliases by command.about | eval man = join(aliases, ', ') + ': ' + command.about | fields man","title":"Command line usage"},{"location":"quickstart/firststeps/#events","text":"M42PL works with events . An event is a single unit of information, which contains one or more fields . You can think of an event as a JSON or YAML document, as a Python's dict (which they are), as a C/C++ structure, etc. Events are generated by Generating commands and processed by Streaming commands & Buffering commands .","title":"Events"},{"location":"quickstart/firststeps/#commands","text":"M42PL support 4 types of commands: Generating commands generates events There is a single generating command per pipeline Generating command are usually put first in the pipeline A pipeline may include sub-pipelines, each of them may include a genrating command Generating commands may be piped into streaming commands , buffering commands and meta commands Streaming commands process events Each streaming command may be piped into another streaming command , buffering command or meta command Buffering commands process block of events Each buffering command may be piped into another buffering command , streaming command or meta command Meta commands forwards the data and manipulates the pipeline itself Each metacommand may be piped into another meta command , streaming command or buffering command","title":"Commands"},{"location":"quickstart/firststeps/#fields","text":"Fields are both the events attributes and a way to access the given attributes . M42PL's commands support 5 type of fields: Literal : A literal value such as a number, a string or a list of values, e.g. 42 , 'some text' , (1, 2, 3) Path : A field name or a doted field name, e.g. field , field.subfield JsonPath : A JsonPath expression, e.g. {list[0].name} Eval : An evaulation expression, e.g. at(list, 0) Pipe : A sub-pipeline, e.g. [ | kvread 'someName' ]","title":"Fields"},{"location":"quickstart/installation/","text":"Installation M42PL is divided into several packages and repositories. If you're starting on the project, you may prefer to use a container image . For more experienced users and developers, you may install the project from source . Container images Two container images are available: jpclipffel/m42pl : standard image, comes with everything pre-installed docker pull jpclipffel/m42pl:latest # Or docker pull ghcr.io/jpclipffel/m42pl:latest jpclipffel/m42pl-core : base image, contains only m42pl-core docker pull jpclipffel/m42pl-core:latest # Or docker pull ghcr.io/jpclipffel/m42pl-core:latest From source M42PL is built on several components ( core , commands , dispatchers , kvstores and encoders ). Installation in a virtual environment If is recomended to install M42PL into a dedicated virtual environement: python -m venv m42pl && source m42pl/bin/activate Installation in development mode If you plan to make change to M42PL, install the component(s) with pip install -e <component> Install the core project m42pl_core : git clone https://github.com/jpclipffel/m42pl-core pip install m42pl-core Install the core commands m42pl_commands : git clone https://github.com/jpclipffel/m42pl-commands pip install m42pl-commands Install the core dispatchers m42pl_dispatchers : git clone https://github.com/jpclipffel/m42pl-dispatchers pip install m42pl-dispatchers Install the core kvstores m42pl_kvsotres : git clone https://github.com/jpclipffel/m42pl-kvstores pip install m42pl-kvstores Install the core encoders m42pl_encoders : git clone https://github.com/jpclipffel/m42pl-encoders pip install m42pl-encoders","title":"Installation"},{"location":"quickstart/installation/#installation","text":"M42PL is divided into several packages and repositories. If you're starting on the project, you may prefer to use a container image . For more experienced users and developers, you may install the project from source .","title":"Installation"},{"location":"quickstart/installation/#container-images","text":"Two container images are available: jpclipffel/m42pl : standard image, comes with everything pre-installed docker pull jpclipffel/m42pl:latest # Or docker pull ghcr.io/jpclipffel/m42pl:latest jpclipffel/m42pl-core : base image, contains only m42pl-core docker pull jpclipffel/m42pl-core:latest # Or docker pull ghcr.io/jpclipffel/m42pl-core:latest","title":" Container images"},{"location":"quickstart/installation/#from-source","text":"M42PL is built on several components ( core , commands , dispatchers , kvstores and encoders ). Installation in a virtual environment If is recomended to install M42PL into a dedicated virtual environement: python -m venv m42pl && source m42pl/bin/activate Installation in development mode If you plan to make change to M42PL, install the component(s) with pip install -e <component> Install the core project m42pl_core : git clone https://github.com/jpclipffel/m42pl-core pip install m42pl-core Install the core commands m42pl_commands : git clone https://github.com/jpclipffel/m42pl-commands pip install m42pl-commands Install the core dispatchers m42pl_dispatchers : git clone https://github.com/jpclipffel/m42pl-dispatchers pip install m42pl-dispatchers Install the core kvstores m42pl_kvsotres : git clone https://github.com/jpclipffel/m42pl-kvstores pip install m42pl-kvstores Install the core encoders m42pl_encoders : git clone https://github.com/jpclipffel/m42pl-encoders pip install m42pl-encoders","title":" From source"},{"location":"utils/","text":"Idioms This chapter documents M42PL utilities available in several commands. Evaluation functions Time expressions Grok (regex patterns)","title":"Overview"},{"location":"utils/#idioms","text":"This chapter documents M42PL utilities available in several commands. Evaluation functions Time expressions Grok (regex patterns)","title":"Idioms"},{"location":"utils/eval/","text":"Evaluation functions M42PL provides a custom evaluator module which evaluates Python expression, provides a set of utilities functions and a custom field accessing syntax. Misc functions field Return the value of <field_name> , or default_value if not found. field(<field_name>, [default_value]) isnull Returns true if expression is None or null , false otherwise. isnull(<expression>) isnotnull Returns true if <expression> is not None nor null , false otherwise. isnotnull(<expression>) coalesce Returns the first non-null expression. Return None if all <expression> are None or null . coalesce(<expression> [, ...]) keys Returns the keys of the given field , or all keys of no field is given. keys([field]) Time functions now Returns the current time as an epoch float. now() reltime Returns a relative time from the given <time expression> (link) reltime(<time expression>) strftime Returns a string representation of <expression> using <format> (link) . strftime(<expression>, [format]]) strptime Returns an epoch float from the <time string> encoded with <format> . strptime(<time string>, <format>) Cast functions tostring Returns a string from the given <expression> . tostring(<expression>) toint Returns a string from the given <expression> . toint(<expression>) tofloat Returns a string from the given <expression> . tofloat(<expression>) String functions clean split strip List functions list join slice idx length Math functions round even true false Filter functions match Path functions basename dirname joinpath cwd","title":"Evaluation functions"},{"location":"utils/eval/#evaluation-functions","text":"M42PL provides a custom evaluator module which evaluates Python expression, provides a set of utilities functions and a custom field accessing syntax.","title":"Evaluation functions"},{"location":"utils/eval/#misc-functions","text":"","title":"Misc functions"},{"location":"utils/eval/#field","text":"Return the value of <field_name> , or default_value if not found. field(<field_name>, [default_value])","title":"field"},{"location":"utils/eval/#isnull","text":"Returns true if expression is None or null , false otherwise. isnull(<expression>)","title":"isnull"},{"location":"utils/eval/#isnotnull","text":"Returns true if <expression> is not None nor null , false otherwise. isnotnull(<expression>)","title":"isnotnull"},{"location":"utils/eval/#coalesce","text":"Returns the first non-null expression. Return None if all <expression> are None or null . coalesce(<expression> [, ...])","title":"coalesce"},{"location":"utils/eval/#keys","text":"Returns the keys of the given field , or all keys of no field is given. keys([field])","title":"keys"},{"location":"utils/eval/#time-functions","text":"","title":"Time functions"},{"location":"utils/eval/#now","text":"Returns the current time as an epoch float. now()","title":"now"},{"location":"utils/eval/#reltime","text":"Returns a relative time from the given <time expression> (link) reltime(<time expression>)","title":"reltime"},{"location":"utils/eval/#strftime","text":"Returns a string representation of <expression> using <format> (link) . strftime(<expression>, [format]])","title":"strftime"},{"location":"utils/eval/#strptime","text":"Returns an epoch float from the <time string> encoded with <format> . strptime(<time string>, <format>)","title":"strptime"},{"location":"utils/eval/#cast-functions","text":"","title":"Cast functions"},{"location":"utils/eval/#tostring","text":"Returns a string from the given <expression> . tostring(<expression>)","title":"tostring"},{"location":"utils/eval/#toint","text":"Returns a string from the given <expression> . toint(<expression>)","title":"toint"},{"location":"utils/eval/#tofloat","text":"Returns a string from the given <expression> . tofloat(<expression>)","title":"tofloat"},{"location":"utils/eval/#string-functions","text":"","title":"String functions"},{"location":"utils/eval/#clean","text":"","title":"clean"},{"location":"utils/eval/#split","text":"","title":"split"},{"location":"utils/eval/#strip","text":"","title":"strip"},{"location":"utils/eval/#list-functions","text":"","title":"List functions"},{"location":"utils/eval/#list","text":"","title":"list"},{"location":"utils/eval/#join","text":"","title":"join"},{"location":"utils/eval/#slice","text":"","title":"slice"},{"location":"utils/eval/#idx","text":"","title":"idx"},{"location":"utils/eval/#length","text":"","title":"length"},{"location":"utils/eval/#math-functions","text":"","title":"Math functions"},{"location":"utils/eval/#round","text":"","title":"round"},{"location":"utils/eval/#even","text":"","title":"even"},{"location":"utils/eval/#true","text":"","title":"true"},{"location":"utils/eval/#false","text":"","title":"false"},{"location":"utils/eval/#filter-functions","text":"","title":"Filter functions"},{"location":"utils/eval/#match","text":"","title":"match"},{"location":"utils/eval/#path-functions","text":"","title":"Path functions"},{"location":"utils/eval/#basename","text":"","title":"basename"},{"location":"utils/eval/#dirname","text":"","title":"dirname"},{"location":"utils/eval/#joinpath","text":"","title":"joinpath"},{"location":"utils/eval/#cwd","text":"","title":"cwd"},{"location":"utils/grok/","text":"Grok Grok is a wrapper around regular expression, which provide a set of ready-to-use patterns which compiles into a standard regular expression. General syntax is: %{<PATTERN>[:name][:rule,...]} Where: <PATTERN> is a Grok pattern name [name] is a field name, which defaults to PATTERN [rule,...] is one or more rule to apply to the extrated value Comparison with Logstash's Grok filter M42PL supports two additionals options: name can refer to a nested field, such as user.name One or more rule can be added after name to post-process the parsed value Example Input: userName=\"john\" userID=42 action=\"login\" Grok expression: userName=\"%{DATA:user.name}\" userID=%{NUMBER:user.id:int} action=\"%{DATA:action.name}\" Result: { \"user\": { \"name\": \"john\", \"id\": 42 }, \"action\": { \"name\": \"login\" } } Patterns The default patterns are available here: Repository Pattern source The author would like to inform that he copied the Grok patterns from the following repository some months ago, and did not manage to find back to original file to source it here: Repository Rules str : Cast to a string int : Cast to an integer float : Cast to a float upper : Convert to uppercase lower : Convert to lowecase list : Convert to a list","title":"Grok (regex patterns)"},{"location":"utils/grok/#grok","text":"Grok is a wrapper around regular expression, which provide a set of ready-to-use patterns which compiles into a standard regular expression. General syntax is: %{<PATTERN>[:name][:rule,...]} Where: <PATTERN> is a Grok pattern name [name] is a field name, which defaults to PATTERN [rule,...] is one or more rule to apply to the extrated value Comparison with Logstash's Grok filter M42PL supports two additionals options: name can refer to a nested field, such as user.name One or more rule can be added after name to post-process the parsed value","title":"Grok"},{"location":"utils/grok/#example","text":"Input: userName=\"john\" userID=42 action=\"login\" Grok expression: userName=\"%{DATA:user.name}\" userID=%{NUMBER:user.id:int} action=\"%{DATA:action.name}\" Result: { \"user\": { \"name\": \"john\", \"id\": 42 }, \"action\": { \"name\": \"login\" } }","title":"Example"},{"location":"utils/grok/#patterns","text":"The default patterns are available here: Repository Pattern source The author would like to inform that he copied the Grok patterns from the following repository some months ago, and did not manage to find back to original file to source it here: Repository","title":"Patterns"},{"location":"utils/grok/#rules","text":"str : Cast to a string int : Cast to an integer float : Cast to a float upper : Convert to uppercase lower : Convert to lowecase list : Convert to a list","title":"Rules"},{"location":"utils/time/","text":"Time expressions M42PL provide a time expression syntax to select time ranges. The general expression syntax is: (-|+)<value><unit>@<precision> Where: (-|+) indicates if you decrement ( - ) or increment ( + ) the time offset By default, M42PL assumes you decrement ( - ) <value> is an integer, representing the number of <unit> to decrement or increment <unit> is the time unit in: ms : microsecond s : second m : minute h : hour d : day <precision> is the current time rounded to: now : microsecond s : second m : minute h : hour d : day","title":"Time expressions"},{"location":"utils/time/#time-expressions","text":"M42PL provide a time expression syntax to select time ranges. The general expression syntax is: (-|+)<value><unit>@<precision> Where: (-|+) indicates if you decrement ( - ) or increment ( + ) the time offset By default, M42PL assumes you decrement ( - ) <value> is an integer, representing the number of <unit> to decrement or increment <unit> is the time unit in: ms : microsecond s : second m : minute h : hour d : day <precision> is the current time rounded to: now : microsecond s : second m : minute h : hour d : day","title":"Time expressions"}]}